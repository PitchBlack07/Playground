#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <intrin.h>
#include "hfloat.h"
#include "half.h"

//
// from ftp://www.fox-toolkit.org/pub/fasthalffloatconversion.pdf
//

static const uint16_t btable[] =
{
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
	0x0200, 0x0400, 0x0800, 0x0c00, 0x1000, 0x1400, 0x1800, 0x1c00, 0x2000, 0x2400, 0x2800, 0x2c00, 0x3000, 0x3400, 0x3800, 0x3c00,
	0x4000, 0x4400, 0x4800, 0x4c00, 0x5000, 0x5400, 0x5800, 0x5c00, 0x6000, 0x6400, 0x6800, 0x6c00, 0x7000, 0x7400, 0x7800, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00, 0x7c00,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
	0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
	0x8200, 0x8400, 0x8800, 0x8c00, 0x9000, 0x9400, 0x9800, 0x9c00, 0xa000, 0xa400, 0xa800, 0xac00, 0xb000, 0xb400, 0xb800, 0xbc00,
	0xc000, 0xc400, 0xc800, 0xcc00, 0xd000, 0xd400, 0xd800, 0xdc00, 0xe000, 0xe400, 0xe800, 0xec00, 0xf000, 0xf400, 0xf800, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
	0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00, 0xfc00,
};

static const int8_t stable[] =
{
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0f,
	0x0e, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0d,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0f,
	0x0e, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0d
};


#ifdef GENTABLES
static uint16_t basetable[512];
static int8_t   shifttable[512];


static void generatetables()
{
	uint32_t i;
	for (i = 0; i < 256; ++i)
	{
		const int32_t e = i - 127;
		if (e < -24)
		{
			basetable[i | 0x000] = 0x0000;
			basetable[i | 0x100] = 0x8000;
			shifttable[i | 0x000] = 24;
			shifttable[i | 0x100] = 24;
		}
		else if (e < -14)   // Small numbers map to denorms
		{
			basetable[i | 0x000] = (0x0400 >> (-e - 14));
			basetable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
			shifttable[i | 0x000] = -e - 1;
			shifttable[i | 0x100] = -e - 1;
		}
		else if (e <= 15) { // Normal numbers just lose precision
			basetable[i | 0x000] = ((e + 15) << 10);
			basetable[i | 0x100] = ((e + 15) << 10) | 0x8000;
			shifttable[i | 0x000] = 13;
			shifttable[i | 0x100] = 13;
		}
		else if (e<128) { // Large numbers map to Infinity
			basetable[i | 0x000] = 0x7C00;
			basetable[i | 0x100] = 0xFC00;
			shifttable[i | 0x000] = 24;
			shifttable[i | 0x100] = 24;
		}
		else { // Infinity and NaN's stay Infinity and NaN's
			basetable[i | 0x000] = 0x7C00;
			basetable[i | 0x100] = 0xFC00;
			shifttable[i | 0x000] = 13;
			shifttable[i | 0x100] = 13;
		}
	}
}


#define PRINT_TABLE(name, width) \
for(unsigned int r = 0; r < _countof(name) / width; ++r) { \
	for(unsigned c = 0; c < (width - 1); ++c)  printf("%#04x, ", name[width * r + c]); \
	printf("%#04x,\n", name[width * r + (width-1)]); \
}

#endif

hfloat convert_float_to_hfloat_branch(float f_)
{
	uint32_t f;
	memcpy(&f, &f_, sizeof(f_));

	const uint16_t sign = (f & 0x80000000) >> 16;
	const uint32_t man  = (f & 0x7FFFFF);
	const uint32_t exp  = (f >> 23) & 0xFF;

	const int32_t e = ((int32_t)exp) - 127;
	if (e >= -24 && e < -14)   // Small numbers map to denorms
	{
		return sign | (man >> (-e - 1));
	}
	else if (e < -24)
	{
		return sign;
	}
	else if (e <= 15) { // Normal numbers just lose precision
		return sign | (e << 10) | (man >> 13);
	}
	else if (e<128) { // Large numbers map to Infinity
		return sign | 0x7C00;
	}
	else { // Infinity and NaN's stay Infinity and NaN's
		return sign | 0x7FFF;
	}
}

hfloat convert_float_to_hfloat(float f_)
{
	uint32_t f;
	memcpy(&f, &f_, sizeof(f_));

	return btable[(f >> 23) & 0x1ff] + ((f & 0x007fffff) >> stable[(f >> 23) & 0x1ff]);
	//return btable[(f >> 23) & 0xff] + ((f & 0x007fffff) >> stable[(f >> 23) & 0xff]) | ((f >> 16) & 0x8000);
}

static float uint_to_float(uint32_t v)
{
	float f;
	memcpy(&f, &v, sizeof(f));

	return f;
}


float convert_hfloat_to_float(hfloat f_)
{
	static const uint32_t HALF_FLOAT_MANTISSA_BITS = 10;

	uint32_t sign = ((uint32_t)(f_ & 0x8000)) << 16;
	uint32_t m = (uint32_t)(f_ & 0x03FF);
	int32_t  e = (int32_t)((f_ & 0x7C00));

	if (e > 0x00 && e < 0x7C00)
	{
		// normalized number
		return uint_to_float(sign | ((e + 0x1C000) << 13) | (m << 13));
	}
	else if ((f_ & 0x7FFFF) == 0)
	{
		return 0.f;
	}
	else if (e == 0x00)
	{
		uint32_t msb; // index of most signficant bit
		_BitScanReverse(&msb, m);

		// shift 
		const uint32_t dExp = 10 - msb;

		// displaced exponent
		const uint32_t fexp = 127 - 14 - dExp;
		const uint32_t fm   = m << (13 + dExp);

		return uint_to_float(sign | (fexp << 23) | (fm & 0x7FFFFF));
	}
	else if (m == 0)
	{
		return uint_to_float(sign | 0xFF << 23);
	}
	else
	{
		return uint_to_float(sign | (0xFF << 23) | (0x7FFFFF));
	}
}

float make_float(uint32_t s, uint32_t e, uint32_t m)
{
	return uint_to_float(s << 31 | ((e & 0xff) << 23) | (m & 0x7FFFFF));
}

#define FLT_COUNT 1024 * 1024

float* make_float_array()
{
	float* values = malloc(sizeof(float) * FLT_COUNT);
	if (values)
	{
		for (uint32_t i = 0; i < FLT_COUNT; ++i)
		{
			const int32_t tmp   = rand();
			const uint32_t sign = tmp - RAND_MAX < 0 ? 0 : 1;
			const uint32_t exp  = 113 + (uint32_t)((((float)rand()) / RAND_MAX) * 30.f);
			const uint32_t man  = rand() & 0x3FF;

			values[i] = make_float(sign, exp, man);
		}
	}
	return values;
}

int main(int argc, char** argv)
{
	uint64_t freq;
	uint64_t start, end;
	QueryPerformanceFrequency((LARGE_INTEGER*)&freq);

	freq /= 1000000;

	float* values32  = make_float_array();
	hfloat* values16_1 = malloc(sizeof(hfloat) * FLT_COUNT);
	hfloat* values16_2 = malloc(sizeof(hfloat) * FLT_COUNT);
	hfloat* values16_3 = malloc(sizeof(hfloat) * FLT_COUNT);

	QueryPerformanceCounter((LARGE_INTEGER*)&start);

	for (uint32_t i = 0; i < FLT_COUNT; ++i)
	{
		values16_1[i] = convert_float_to_hfloat(values32[i]);
	}


	QueryPerformanceCounter((LARGE_INTEGER*)&end);

	uint64_t delta0 = end - start;

	QueryPerformanceCounter((LARGE_INTEGER*)&start);

	for (uint32_t i = 0; i < FLT_COUNT; ++i)
	{
		uint32_t ftmp;
		memcpy(&ftmp, &values32[i], sizeof(values32[i]));
		
		values16_1[i] = half_from_float(ftmp);
	}
	
	QueryPerformanceCounter((LARGE_INTEGER*)&end);

	uint64_t delta1 = end - start;

	QueryPerformanceCounter((LARGE_INTEGER*)&start);

	for (uint32_t i = 0; i < FLT_COUNT; ++i)
	{
		uint32_t ftmp;
		memcpy(&ftmp, &values32[i], sizeof(values32[i]));

		values16_2[i] = convert_float_to_hfloat_branch(ftmp);
	}

	QueryPerformanceCounter((LARGE_INTEGER*)&end);
	uint64_t delta2 = end - start;

	uint64_t time0 = delta0 / freq;
	uint64_t time1 = delta1 / freq;
	uint64_t time2 = delta2 / freq;

	printf("Time0 = %u us, Time1 = %u us, Time2 = %u us\n", (uint32_t)time0, (uint32_t)time1, (uint32_t) time2);

	int i = memcmp(values16_1, values16_2, sizeof(hfloat) * FLT_COUNT);
	int j = memcmp(values16_1, values16_3, sizeof(hfloat) * FLT_COUNT);
	int k = memcmp(values16_2, values16_3, sizeof(hfloat) * FLT_COUNT);

	printf("i = %i, j = %i, k = %i\n", i, j, k);
	
	hfloat test = convert_float_to_hfloat(-23.f);
	float ftest = convert_hfloat_to_float(test);

	//return test == ftest;

	return i * j * (test == ftest);
}


